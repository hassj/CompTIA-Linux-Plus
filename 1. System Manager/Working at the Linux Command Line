Now, let's get this straight
right from the start, shall we?
The very, very best way for you to learn
is to you to get the systems up and running,
so you can run through these demonstrations as well.
We're gonna be taking a look
at working with both files and directories.
We'll take a quick look
at the file system hierarchy standard.
So, while most Linux systems will look very similar
when we look at their directory structure,
we'll see how we can change directories, create directories,
list directory and file metadata, delete directories,
and here we are.
A command line environment,
and a command line environment built upon AlmaLinux 8.5.
Now, rather than using Red Hat Enterprise Linux 8.5,
we are using AlmaLinux 8, as it's a Red Hat rebuild.
It really takes over from where CentOS left off,
in that it becomes a free-to-use alternative
to Red Hat Enterprise Linux 8.
Where we had previously used CentOS,
CentOS now tracks in front of, or ahead of,
Red Hat Enterprise Linux 8,
so it works really as a development platform.
AlmaLinux 8 is a free download
and is free to use without a subscription.
You can see I've also got tabs open for open OpenSUSE
and that's OpenSUSE 15.2 and Ubuntu 2004.
Now, one of the very first things that we might try out
is the use of the TTY command,
to understand the terminal that we've connected to.
Typing the TTY command and then enter,
we can see that we are presented
with a file name and path, so /dev, our device directory,
pts, for pseudo terminal and 0, for pseudo terminal one.
Now, this is just a file within our file system.
We can use the ls, or list command,
with the option -l to be able to go through
and take a look at our file.
l will give me the metadata,
as we can see as we print this.
Now, we should also all be about shortcuts
and making the command line work for us.
If I use ls -l and then use the dollar and parentheses,
I can look at the output of the TTY command
and pass that through to ls -l,
so I can do everything in one command,
rather than two separate commands.
Now, as we take a look at this metadata, in column one,
we can see our file type.
As a c, it means it's a character device, a terminal.
Next, in column two, we have nine bits
that represent our file permissions,
or what's known as our file mode.
When we look at column three, we see the number one here.
Column three is our hard link counts.
It's how many names we have pointing through to our files.
And again, there'll be more details on that
as we work our way through.
When we take a look at column four,
we are looking at the user owner.
That's the user vagrant in this case.
Now, in column five, we see the group owner,
it's TTY, in this case.
Next, we then go through and take a look at the file size.
File size here is 136 bytes.
Column seven will display the last modified time
and then we look in column eight
at the actual file name itself.
Now, these terminals are device files,
hence they're in the dev directory, slash D-E-V.
Now, every directory in Linux does have a purpose
and these directories, and the structure that we look at,
are going to be consistent,
irrespective of the distribution that we look at.
To help demonstrate the file system hierarchy structure,
the consistency that we have across Linux,
I can use the tree command.
Now, you might run it as I've done here
and we are just getting a report
that the tree command is not found, so it's not installed.
We can install it and we are quite lucky
that the tree command actually comes
within a package called tree.
So I can elevate my privileges using sudo.
And then, dnf is my software installer
that we have on AlmaLinux 8.
dnf, Dandified YUM
and then install -y and tree.
Now, we're not always gonna be as lucky
of having the same package name as the command name,
but it's an easy illustration in this case.
But there'll be more on software management
as we go through different modules and courses
within this track.
And now that I do have the tree command installed,
I can show you the root of our file system.
Minus uppercase L will allow me to specify the level
and I only want to go down one level
and taking a look at the root file system,
the top of our file system hierarchy,
we can then go through and see the directories that we have.
I could run the same command across OpenSUSE and Ubuntu
and it would look very similar.
The idea is that we should be able to recognize
the directories and their purpose.
So the bin directory is user binaries,
so it's not a trashcan, it's a binary directory.
User programs.
The boot directory is where we are going to find the kernel.
The dev directories, we've already talked about.
We're gonna find device files.
Our etc directory is our server configuration directory.
We have things like the home directory,
where user home directories are going to be.
We can see as we move further down,
we have directories like the sbin,
which is our supervisory binary, or our root programs.
And moving further down, we can see directories like var,
where we would have variable data,
like mail, spool files and log files.
We did see earlier our device file for our terminal,
but we can look inside of our dev directory, ls -l
and taking a look inside of /dev.
It's gonna list all of the device files
located inside the directory dev.
If I use the tree command, we're gonna be able to navigate
into the dev directory,
as well as all of the sub directories inside of dev.
So many of our device files
are organized in sub directories.
If I want to look at the directory itself,
I can use ls -l and d for directory and /dev.
Here, when we look at our metadata,
we see the file type is d for directory.
We then can see our permissions.
When we take a look at the hard link count,
this is set to 18.
This is an indication of how many sub directories we have
within the dev directory structure.
The ownership is root and root.
We can go through and see the file size
and we can look at the date it was created.
Where we have the execute permission to a directory,
we can move into the directory with a cd command.
pwd will print our working directory.
cd by itself actually takes us to our home directory.
Again, we can see that
with the pwd, print working directory.
We've also got shortcuts that are built in.
If I use cd -,
we actually move to our old working directory
and that's maintained by a variable in the system.
We can read our variables using the echo command
and $OLDPWD, in uppercase,
will show me the directory that I was previously in
and I can use cd -,
or I could cd to the value of the variable,
so, cd $OLDPWD.
But it just gives you an idea, again,
of some of those shortcuts
and how we can make life easy for ourselves
at the command line.
Now, working in my home directory, I can go through
and create a new directory with the mkdir command.
Again, concentrating on the shortcut,
if I want to then list that directory, I can use ls -ld
and Escape + . brings up the last argument.
When we go through and take a look at this, we are again
seeing our metadata, d for directory.
We see our permissions.
We've got a hard link count of 2, representing then,
that we've got the directory
and no additional sub directories.
In each directory,
we also have a file called .
that points to the current directory.
So test/. is pointing back to the test directory.
Hence then, that we have our hard link count of 2.
The number of names we've got the test directory
and test/. all pointing to exactly the same file.
If I want to create parent directories, as well,
I can use mkdir -p and then test/d1/d2.
Returning to my valuable tree command, we can now
list the contents of the directory recursively with tree
and see then that we've got d2 created inside of d1.
But we are not stuck with just this.
If I wanted to go through and create many directories,
I could create mkdir test and then go through and put,
d and then decide, so we could have 1 through 2.
Well, I've already got a directory one,
so why don't we have directory 10 through to directory 19
and we're using the brace brackets there to encapsulate it.
Now, as we go through and take a look
at our tree command, tree and test,
we can see, then, that I've got the directories
d10, d11, d12, and so forth.
Now, having created those directories,
I can delete them in one go
by deleting the top level directory test with rm -rf.